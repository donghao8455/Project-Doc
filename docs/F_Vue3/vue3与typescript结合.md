## `vue3`与`typescript`结合

我们在写代码的时候，编辑器就会提供我们类型，比如创建一个对象，里面加上一些属性，当我们后续使用这个变量时，我们输入这个变量加上.就能看到这个属性，在过去我们的`ide`会为我们进行提供这些功能，有比较强的代码提示，但是对于使用后端传递过来的数据时，我们是无法通过上述方式进行属性的提示的（因为系统只能查询到这个类型是`any`，不知道返回的数据具体是什么样的类型，所以就无法给我们代码提示），基于这个情况，我们需要使用`TS`强类型提示的功能

我们使用`TS`的主要原因是我们想要知道函数，变量，类方法等这些东西到底是什么，所以需要`TS`进行定义类型，使用`TS`进行开发的好处：

- 有强的类型提示，能够使后端传递过来的数据也具有类型提示

- 对于类型不匹配的参数使用，结合`TS`进行开发，在开发阶段就会将错误进行抛出，方便程序员及时修改

```vue
<script setup lang="ts">
const f = { name: 'abc' }  // 这个情况下，编辑器会进行类型的识别，不需要人为设置
// 这个情况在ts语法下，在代码中就会出现类型报错，不能将数字类型分配给字符串
f.name = 12 
</script>
```

鼠标放到`f`上，会自动出现系统的类型提示：

```ts
const f: {
    name: string;
}
```

现在我们给`f`添加一个`age`属性，其类型为`number`，其值为20

```ts
f.age = 20  
```

这样添加是不行的，会出现以下的报错信息：

```ts
类型"{ name: string; }"上不存在属性"age"。
```

因为`f`只有一个属性`name`，所以默认提供给我们的是不行的，因此我们需要进行定制，进行声明类型：

```ts
const f: { name: string, age?: number } = { name: 'abc' }

f.age = 20  // 声明类型后使用，这样就不报错了
```

一般我们会将类型单独的拿出来写：

```ts
type user = { name: string, age?: number }
const f: user = { name: 'abc' }
```

总之，如果系统给的默认推断类型够用，我们就不需要进行类型设置，如果类型不够用，我们在进行类型设置

当然也可以对`f`进行类型的设置，对`f`进行修改，这是我们就不能用`const`进行声明了：

```ts
const f: user | string | boolean = { name: 'abc' }
f = true  // 这样修改是正确的
```

***

### 异步数据请求没有类型提示情况

在不使用`TS`的情况下，提供后端去请求异步的数据，之后我们调用这个数据，是不会出现该数据属性的类型提示的，数据的属性名称也不会进行提示的给出，我们一般需要到接口/网络请求中进行后端传递的数据中进行属性的查询，如果属性敲错了，代码中也是不会进行报错的（但是运行的时候会报错，可能也不报错，如果数据中没有这个属性，读取到的是`undefined`，那么就什么也看不见），因为系统根本就不知道这个异步的数据中有什么属性，系统返回的类型是`any`（不确定是什么东西）在`ts`语法中，尽量杜绝使用类型为`any`的变量

***

### 通过泛型声明类型

所以我们就需要使用`TS`语法，给异步请求的数据加上类型，那么当我们写错属性的时候就会在代码处进行报错：

```ts
// res是调用后端返回的数据
const art = ref<{ title: string }>(res)  // 声明类型（泛型声明）
art.name   // 这种情况就会报错，我们在开发的过程中就可以及时的改正
// 输入art，就会出现类型提示，可以知道该数据有哪些属性，方便我们直接使用
```

但是对于异步调用过来的后端数据，我们不能在使用后端数据的时候，在每个地方都进行像上述样子的定义，我们需要将其做成可复用的形式，我们一般建立一个文件夹`composables`，用于存放一些可复用的功能，我们在该文件下创建一个文件`useApi.ts`来定义我们从后端调用的数据

然而，通过泛型参数来定义 props 的类型通常更直接,称之为“基于类型的声明”

```vue
<script setup lang="ts">
const props = defineProps<{
  foo: string
  bar?: number
}>()
</script>
```

